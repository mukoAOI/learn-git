虚拟存储（Virtual Memory）系统通过地址转换机制（硬件 + 操作系统协作）为每个进程**创造了一个连续且独立的虚拟地址空间的“幻觉”**。它本身**并不保证物理内存的连续性**，而是巧妙地解决了物理内存碎片化问题，让程序员和进程无需关心底层物理内存的实际布局。

以下是虚拟存储如何实现这种“连续性幻觉”的关键机制：

1.  **地址空间划分（分页/分段）：**
    *   操作系统将进程的虚拟地址空间划分为小的、固定大小的单元（最常见的是**页**），通常大小为 4KB 或 2MB。物理内存也被划分为相同大小的单元（称为**页帧**或**物理块**）。
    *   （另一种方式是分段，但现代操作系统主要使用分页或段页式结合）。

2.  **页表（Page Table）：**
    *   这是虚拟存储的核心数据结构，由操作系统为每个进程维护。
    *   页表存储了**虚拟页号（VPN）到物理帧号（PFN）的映射关系**。
    *   每个虚拟页在页表中都有一项（称为页表项 - PTE），记录了：
        *   该虚拟页当前映射到的物理帧号（如果它在物理内存中）。
        *   状态位（如存在位、修改位、访问位、读写权限位等）。**“存在位”** 尤其重要，它指示该页当前是否在物理内存中。

3.  **内存管理单元（MMU - Memory Management Unit）：**
    *   这是CPU中的一个专用硬件部件。
    *   当CPU执行指令，需要访问一个虚拟地址时（无论是取指令还是读写数据），MMU自动拦截这个访问请求。
    *   MMU的工作流程：
        1.  **提取虚拟页号：** 从虚拟地址中提取出虚拟页号（VPN）。
        2.  **查询页表：** 使用VPN作为索引，查找进程页表中对应的页表项（PTE）。这个查找过程可能涉及多级页表遍历。
        3.  **检查“存在位”：**
            *   如果PTE的**存在位为1**：表示该虚拟页当前驻留在物理内存中。MMU从PTE中取出物理帧号（PFN）。
            *   如果PTE的**存在位为0**：表示该虚拟页当前**不在**物理内存中（可能在磁盘上的交换空间）。这时MMU会触发一个**缺页异常**。
        4.  **地址转换（存在时）：** 将虚拟地址中的**页内偏移量**直接拼接到找到的物理帧号（PFN）后面，组合成最终的物理地址。
        5.  **访问物理内存：** CPU使用这个物理地址去访问实际的物理内存。

4.  **缺页异常处理：**
    *   当MMU发现一个虚拟页不在物理内存中（存在位=0）时，触发缺页异常。
    *   CPU暂停当前进程的执行，将控制权交给操作系统的缺页异常处理程序。
    *   操作系统处理程序：
        1.  检查该虚拟地址是否合法（在进程的地址空间范围内且有访问权限）。
        2.  在物理内存中找到一个空闲的页帧。如果没有空闲帧，需要根据页面置换算法（如LRU）选择一个“牺牲”页帧。
        3.  如果“牺牲”页帧的内容被修改过（脏页），需要先将其内容写回磁盘（交换空间）。
        4.  将所需的虚拟页（当前在磁盘交换空间中）的内容读入到选定的物理页帧中。
        5.  更新页表项：将该虚拟页号映射到新的物理帧号，并将存在位置为1。
        6.  重新启动引发缺页异常的指令。

**如何保证虚拟地址空间的连续性：**

1.  **页表映射的灵活性：**
    *   页表机制的核心在于，**虚拟页号（VPN）到物理帧号（PFN）的映射是完全任意的、独立的**。
    *   操作系统在分配物理内存给一个进程时，**不需要寻找连续的物理页帧**。它只需要为进程请求的每一个虚拟页（无论它们在虚拟地址空间中是否连续）找到一个空闲的物理页帧（可能分散在物理内存各处），并在页表中建立对应的映射即可。
    *   例如，进程的虚拟页 0 可以映射到物理帧 100，虚拟页 1 映射到物理帧 50，虚拟页 2 映射到物理帧 200。尽管物理帧 50、100、200 在物理上完全不连续，但进程访问虚拟地址 0x0000, 0x1000, 0x2000（对应虚拟页 0,1,2）时，通过页表映射，它能无缝地访问到物理地址 100*页大小, 50*页大小, 200*页大小 处的内存，感觉就像在访问一块连续的内存。

2.  **对进程透明：**
    *   进程看到的**只有自己那连续的虚拟地址空间（从 0 到最大地址）**。
    *   MMU 和页表在背后默默完成了所有从虚拟地址到可能非常分散的物理地址的转换工作。进程完全感知不到物理内存的实际分布是支离破碎的。

3.  **动态加载：**
    *   虚拟存储允许进程的代码、数据、堆栈等部分在真正需要时（发生缺页异常）才被加载到物理内存中，并且加载到哪里（哪个物理页帧）由操作系统动态决定，同样只需更新页表映射。这种按需加载和灵活映射进一步减少了对连续物理内存的需求。

**总结：**

虚拟存储**不保证也不要求物理内存的连续性**。它通过**页表（软件）和MMU（硬件）** 实现的**地址转换机制**，为每个进程构建了一个**独立、连续、统一的虚拟地址空间视图**。操作系统利用页表，将进程虚拟地址空间中连续的页，灵活地映射到物理内存中任意可用的、可能完全不连续的页帧上。正是这种**任意的、按页的映射关系**，使得物理内存的碎片化对进程完全不可见，从而“保证”了进程视角下内存访问的连续性。这种机制是解决物理内存碎片、实现内存超额分配（运行比物理内存总和还大的程序）和进程隔离的关键基础。