计算机触发中断时，需要执行一系列精确的硬件和软件操作，以确保当前任务被正确暂停、中断原因得到处理、最后能安全返回原任务。这个过程通常分为以下几个关键阶段：

1.  **中断请求**
    *   **事件发生：** 一个需要CPU注意的事件发生（例如：外部设备完成I/O操作、定时器到期、硬件故障、软件执行`int`指令、除零错误等）。
    *   **信号发出：** 相应的硬件（如设备控制器、定时器、CPU内部的异常检测单元）或软件向CPU的中断控制器（如8259 PIC或现代的APIC/x2APIC）发出一个**中断请求信号**。

2.  **中断检测与响应**
    *   **CPU检查：** CPU在完成当前指令的执行后（或有时在指令执行中途，如页错误），会检查其**中断引脚**或**中断控制器**的状态，看是否有挂起的中断请求。
    *   **中断使能检查：** CPU检查其**内部的中断允许标志位**（例如x86的`IF`标志）。如果中断被全局禁止（IF=0），则忽略可屏蔽中断请求（NMI不可屏蔽，会立即处理）。
    *   **中断优先级裁决：** 如果有多个中断同时请求，中断控制器会根据预设的**优先级**（IRQ0通常最高）选择一个当前优先级最高的中断。
    *   **中断响应：** CPU通过中断应答周期向中断控制器确认接收到了中断请求。中断控制器则在数据总线上提供该中断的**中断向量号**（一个0到255之间的索引值）。

3.  **硬件自动操作（上下文保存 - 硬件部分）**
    *   **关键寄存器压栈：** CPU硬件**自动**执行以下操作：
        *   将**标志寄存器**（EFLAGS/RFLAGS）的内容压入内核栈。
        *   将**代码段寄存器**（CS）的内容压入内核栈。
        *   将**指令指针**（EIP/RIP）的内容（即下一条要执行指令的地址）压入内核栈。
        *   （某些架构/模式下）可能还会自动压入**错误码**（对于某些特定的异常，如页错误）。
    *   **目的：** 保存被中断程序的**关键执行状态**（程序计数器、标志位），以便中断处理结束后能精确恢复执行。这通常被称为保存“硬件上下文”。

4.  **加载中断服务程序**
    *   **定位入口点：** CPU使用从中断控制器获取的**中断向量号**作为索引，查询**中断描述符表**。
    *   **获取入口地址：** 从IDT对应的表项中读取该中断对应的**中断服务程序**的入口地址（段选择子和偏移量）。
    *   **权限检查：** CPU进行必要的特权级检查（例如，用户态程序触发中断会切换到内核态）。
    *   **加载CS:EIP/RIP：** CPU将新的CS和EIP/RIP加载到相应的寄存器中，从而将控制权**跳转**到中断服务程序的起始指令处。

5.  **软件操作（中断服务程序执行 - 上下文保存软件部分 & 中断处理）**
    *   **保存完整上下文：** 中断服务程序（通常是操作系统内核的一部分）的**第一条指令**通常是进一步保存CPU**通用寄存器**（EAX, EBX, ECX, EDX, EBP, ESI, EDI等）的状态到内核栈。这称为保存“软件上下文”。
    *   **设置环境（可选）：** 可能需要设置内核数据段（DS, ES等），建立栈帧等。
    *   **识别中断源（可选）：** 对于共享中断线的情况，可能需要读取设备状态寄存器来确定具体是哪个设备发出的中断。
    *   **执行中断处理：** 执行处理该中断事件所需的实际工作。例如：
        *   I/O中断：从设备缓冲区读取数据或向其中写入数据，唤醒等待该I/O完成的进程。
        *   定时器中断：更新系统时间，执行调度程序（可能进行进程切换）。
        *   页错误：将缺失的页面从磁盘装入内存，更新页表。
        *   系统调用：根据寄存器参数执行内核服务。
    *   **发送EOI：** 对于使用PIC/APIC的可屏蔽中断，在处理完成后，必须向中断控制器发送**中断结束**命令，通知它该中断已被处理，可以接收新的同级别或更低级别的中断了。
    *   **中断嵌套（可选）：** 在处理当前中断时，如果允许中断嵌套（通常是更高优先级的中断），CPU可能会再次被中断。这时会重复上述过程（保存上下文、处理新中断、恢复），形成嵌套。需要仔细管理栈空间。

6.  **中断返回**
    *   **恢复上下文：** 中断服务程序执行到最后，执行`iret`指令。
    *   **恢复寄存器：** `iret`指令触发CPU硬件自动执行以下操作：
        *   从栈中弹出EIP/RIP（恢复下一条指令地址）。
        *   从栈中弹出CS（恢复代码段）。
        *   从栈中弹出EFLAGS/RFLAGS（恢复标志寄存器状态，包括中断允许位IF）。
    *   **恢复执行：** CPU根据恢复的CS:EIP/RIP，继续执行被中断的程序。如果中断处理过程中发生了进程切换（例如在定时器中断中调度器运行了），那么恢复的上下文将是新进程的上下文。

**总结关键操作：**

1.  **事件发生，请求中断。**
2.  **CPU检测并响应（优先级、使能）。**
3.  **硬件自动保存关键状态（EFLAGS, CS, EIP）到栈。**
4.  **CPU加载中断服务程序入口（查IDT）。**
5.  **中断服务程序保存其他寄存器（软件保存）。**
6.  **执行实际的中断处理逻辑。**
7.  **（可屏蔽中断）发送EOI。**
8.  **中断服务程序恢复保存的其他寄存器。**
9.  **执行`iret`指令，硬件恢复CS, EIP, EFLAGS。**
10. **CPU继续执行被中断的程序。**

这个过程确保了CPU能够及时响应外部事件和内部错误，同时又能无缝地恢复被中断任务的执行，是现代操作系统实现并发、设备驱动、错误处理等核心功能的基础。