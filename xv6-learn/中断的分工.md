在计算机系统中，中断处理是**硬件和操作系统（软件）紧密协作**的过程。以下是中断过程中硬件和操作系统的典型分工：

---

### **一、硬件负责的部分（自动、快速响应）**
1. **中断触发与检测**：
   - **外设硬件**（如键盘、网卡、定时器）在需要时（如数据到达、按键按下）向**中断控制器（如APIC）** 发送中断请求信号。
   - **CPU** 在每条指令执行结束后，检查中断请求线是否有信号。

2. **中断响应**：
   - 若中断未被屏蔽，CPU **暂停当前执行流**，保存**关键硬件状态**（如程序计数器PC、程序状态字PSW）到内核栈或特定寄存器。
   - CPU 从中断控制器获取**中断向量号**（一个标识中断类型的数字）。

3. **初步跳转**：
   - CPU 根据中断向量号，查询预先设置好的**中断向量表**（由操作系统初始化），找到对应的**中断服务程序（ISR）入口地址**。
   - CPU **跳转到ISR的起始地址**，开始执行中断处理代码（此时控制权转移到软件）。

---

### **二、操作系统负责的部分（灵活、复杂处理）**
1. **保存完整上下文**：
   - 硬件仅保存PC和PSW等少量状态。操作系统**保存当前任务的所有寄存器**（如通用寄存器、浮点寄存器）到其**内核栈**，确保后续能恢复现场。

2. **识别中断源**：
   - 根据中断向量号，操作系统调用**对应的中断处理程序**（如键盘驱动、网卡驱动中的处理函数）。

3. **执行中断服务**：
   - 执行与中断相关的核心操作（例如：
     - **键盘中断**：读取按键扫描码，存入输入缓冲区。
     - **磁盘中断**：处理I/O完成通知，唤醒等待该I/O的进程。
     - **时钟中断**：更新系统时间，触发进程调度器）。

4. **中断嵌套与屏蔽**：
   - 操作系统可临时屏蔽/启用中断，防止关键代码被中断打断（如通过`cli`/`sti`指令）。
   - 处理中断嵌套（高优先级中断抢占低优先级中断）。

5. **调度与唤醒**：
   - 若中断导致某等待中的进程就绪（如I/O完成），操作系统将其加入就绪队列。
   - 在**时钟中断**中，操作系统可能触发**进程调度器**，决定是否切换进程。

6. **恢复现场与返回**：
   - 从内核栈中恢复所有保存的寄存器状态。
   - 执行**中断返回指令**（如x86的`IRET`），硬件自动恢复PC和PSW，回到被中断的程序继续执行。

---

### **关键协作流程示例（以网卡接收数据包为例）**
| 步骤                | 执行者 | 操作                                   |
| ------------------- | ------ | -------------------------------------- |
| 1. 数据包到达网卡   | 硬件   | 网卡产生中断信号                       |
| 2. CPU响应中断      | 硬件   | 保存PC/PSW，跳转到ISR入口              |
| 3. 保存寄存器上下文 | OS     | 保存用户进程的完整状态到内核栈         |
| 4. 识别中断源       | OS     | 根据中断号调用网卡驱动ISR              |
| 5. 读取数据包       | OS     | 从网卡缓冲区复制数据到内核内存         |
| 6. 通知协议栈       | OS     | 向上层网络协议传递数据包               |
| 7. 唤醒进程         | OS     | 若进程阻塞在`recv()`调用，则标记为就绪 |
| 8. 恢复现场         | OS     | 从内核栈恢复寄存器                     |
| 9. 中断返回         | 硬件   | 恢复PC/PSW，继续执行被中断代码         |

---

### **为什么需要软硬件协作？**
- **硬件**：提供**快速响应机制**（微秒级），但功能固定简单。
- **操作系统**：提供**复杂逻辑处理**（如进程调度、文件系统），但速度较慢（毫秒级）。
  
> 📌 **关键点**：硬件负责“打断和跳转”，操作系统负责“该做什么以及如何恢复”。两者缺一不可，共同实现高效的系统响应。

通过这种分工，计算机既能及时响应外部事件（如用户输入），又能安全执行复杂任务（如多进程调度），是现代操作系统的核心机制之一。